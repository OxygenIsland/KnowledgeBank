---
title: "[[2.2 A fast matrix-based approach to computing the output from a neural network]]"
type: Literature
status: todo
Creation Date: 2025-01-13 09:45
tags:
---
Before discussing backpropagation, let's warm up with a fast matrix-based algorithm to compute the output from a neural network. We actually already briefly saw this algorithmÂ [near the end of the last chapter](http://neuralnetworksanddeeplearning.com/chap1.html#implementing_our_network_to_classify_digits), but I described it quickly, so it's worth revisiting in detail. In particular, this is a good way of getting comfortable with the notation used in backpropagation, in a familiar context.

Let's begin with a notation which lets us refer to weights in the network in an unambiguous way. We'll use $w_{jk}^{l}$ to denote the weight for the connection from the $k^{\text{th}}$ neuron in the $(l-1)^{\text{th}}$ layer to the $ j^{\text{th}} $ neuron in the $l^{\text{th}}$ layer. So, for example, the diagram below shows the weight on a connection from the fourth neuron in the second layer to the second neuron in the third layer of a network:
![[Pasted image 20250112172500.png|500]]
This notation is cumbersome at first, and it does take some work to master. But with a little effort you'll find the notation becomes easy and natural. One quirk of the notation is the ordering of the $j$ and $k$ indices. You might think that it makes more sense to use $j$ to refer to the input neuron, and $k$ to the output neuron, not vice versa, as is actually done. I'll explain the reason for this quirk below. 

We use a similar notation for the network's biases and activations. Explicitly, we use $b_j^l$ for the bias of the $j^{\text{th}}$ neuron in the $l^{\text{th}}$ layer. And we use $a_j^l$ for the activation of the $j^{\text{th}}$ neuron in the $l^{\text{th}}$ layer. The following diagram shows examples of these notations in use:

![[Pasted image 20250112172654.png|298]]
With these notations, the activation $a_j^l$ of the $j^{\text{th}}$ neuron in the $l^{\text{th}}$ layer is related to the activations in the $(l-1)^{\text{th}}$ layer by the equation (compare Equation (4) and surrounding discussion in the last chapter) $$ a_j^l = \sigma \left( \sum_k w_{jk}^l a_k^{l-1} + b_j^l \right), $$ where the sum is over all neurons $k$ in the $(l-1)^{\text{th}}$ layer. To rewrite this expression in a matrix form we define a weight matrix $w^l$ for each layer, $l$. The entries of the weight matrix $w^l$ are just the weights connecting to the $l^{\text{th}}$ layer of neurons, that is, the entry in the $j^{\text{th}}$ row and $k^{\text{th}}$ column is $w_{jk}^l$. Similarly, for each layer $l$ we define a bias vector, $b^l$. You can probably guess how this works - the components of the bias vector are just the values $b_j^l$, one component for each neuron in the $l^{\text{th}}$ layer. And finally, we define an activation vector $a^l$ whose components are the activations $a_j^l$.

The last ingredient we need to rewrite (23) in a matrix form is the idea of vectorizing a function such as $\sigma$. We met vectorization briefly in the last chapter, but to recap, the idea is that we want to apply a function such as $\sigma$ to every element in a vector $v$. We use the obvious notation $\sigma(v)$ to denote this kind of elementwise application of a function. That is, the components of $\sigma(v)$ are just $\sigma(v)_j = \sigma(v_j)$. As an example, if we have the function $f(x) = x^2$ then the vectorized form of $f$ has the effect $$ f \begin{pmatrix} 2 \\ 3 \end{pmatrix} = \begin{bmatrix} f(2) \\ f(3) \end{bmatrix} = \begin{bmatrix} 4 \\ 9 \end{bmatrix}, $$ that is, the vectorized $f$ just squares every element of the vector. With these notations in mind, Equation (23) can be rewritten in the beautiful and compact vectorized form $$ a^l = \sigma(w^l a^{l-1} + b^l). $$
This expression gives us a much more global way of thinking about how the activations in one layer relate to activations in the previous layer: we just apply the weight matrix to the activations, then add the bias vector, and finally apply the $\sigma$ function*. That global view is often easier and more succinct (and involves fewer indices!) than the neuron-by-neuron view we've taken to now. Think of it as a way of escaping index hell, while remaining precise about what's going on. The expression is also useful in practice, because most matrix libraries provide fast ways of implementing matrix multiplication, vector addition, and vectorization. Indeed, the code in the last chapter made implicit use of this expression to compute the behaviour of the network. 

When using Equation (25) to compute $a^l$, we compute the intermediate quantity $z^l \equiv w^l a^{l-1} + b^l$ along the way. This quantity turns out to be useful enough to be worth naming: we call $z^l$ the weighted input to the neurons in layer $l$. We'll make considerable use of the weighted input $z^l$ later in the chapter. Equation (25) is sometimes written in terms of the weighted input, as $a^l = \sigma(z^l)$. It's also worth noting that $z^l$ has components $z^l_j = \sum_k w^l_{jk} a^{l-1}_k + b^l_j$, that is, $ z^l_j $ is just the weighted input to the activation function for neuron $j$ in layer $l$.