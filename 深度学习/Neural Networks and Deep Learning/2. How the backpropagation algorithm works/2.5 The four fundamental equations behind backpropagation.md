---
title: "[[2.5 The four fundamental equations behind backpropagation]]"
type: Literature
status: todo
Creation Date: 2025-01-13 09:45
tags:
---
Backpropagation is about understanding how changing the weights and biases in a network changes the cost function. Ultimately, this means computing the partial derivatives $\frac{\partial C}{\partial w_{jk}^l}$ and $\frac{\partial C}{\partial b_j^l}$. But to compute those, we first introduce an intermediate quantity, $\delta_j^l$, which we call the error in the $j^{\text{th}}$ neuron in the $l^{\text{th}}$ layer. Backpropagation will give us a procedure to compute the error $\delta_j^l$, and then will relate $\delta_j^l$ to $\frac{\partial C}{\partial w_{jk}^l}$ and $\frac{\partial C}{\partial b_j^l}$. 
To understand how the error is defined, imagine there is a demon in our neural network:
![[Pasted image 20250112174328.png|500]]
The demon sits at the $j^{\text{th}}$ neuron in layer $l$. As the input to the neuron comes in, the demon messes with the neuron's operation. It adds a little change $\Delta z_j^l$ to the neuron's weighted input, so that instead of outputting $\sigma(z_j^l)$, the neuron instead outputs $\sigma(z_j^l + \Delta z_j^l)$. This change propagates through later layers in the network, finally causing the overall cost to change by an amount $\frac{\partial C}{\partial z_j^l} \Delta z_j^l$. 

Now, this demon is a good demon, and is trying to help you improve the cost, i.e., they're trying to find a $\Delta z_j^l$ which makes the cost smaller. Suppose $\frac{\partial C}{\partial z_j^l}$ has a large value (either positive or negative). Then the demon can lower the cost quite a bit by choosing $\Delta z_j^l$ to have the opposite sign to $\frac{\partial C}{\partial z_j^l}$. By contrast, if $\frac{\partial C}{\partial z_j^l}$ is close to zero, then the demon can't improve the cost much at all by perturbing the weighted input $z_j^l$. So far as the demon can tell, the neuron is already pretty near optimal*. And so there's a heuristic sense in which $\frac{\partial C}{\partial z_j^l}$ is a measure of the error in the neuron. Motivated by this story, we define the error $\delta_j^l$ of neuron $j$ in layer $l$ by $$ \delta_j^l \equiv \frac{\partial C}{\partial z_j^l}. $$ As per our usual conventions, we use $\delta^l$ to denote the vector of errors associated with layer $l$. Backpropagation will give us a way of computing $\delta^l$ for every layer, and then relating those errors to the quantities of real interest, $\frac{\partial C}{\partial w_{jk}^l}$ and $\frac{\partial C}{\partial b_j^l}$.

You might wonder why the demon is changing the weighted input $z_j^l$. Surely it'd be more natural to imagine the demon changing the output activation $a_j^l$, with the result that we'd be using $\frac{\partial C}{\partial a_j}$ as our measure of error. In fact, if you do this things work out quite similarly to the discussion below. But it turns out to make the presentation of backpropagation a little more algebraically complicated. So we'll stick with $\delta_j^l = \frac{\partial C}{\partial z_j^l}$ as our measure of error*. 

**Plan of attack:** Backpropagation is based around four fundamental equations. Together, those equations give us a way of computing both the error $\delta^l$ and the gradient of the cost function. I state the four equations below. Be warned, though: you shouldn't expect to instantaneously assimilate the equations. Such an expectation will lead to disappointment. In fact, the backpropagation equations are so rich that understanding them well requires considerable time and patience as you gradually delve deeper into the equations. The good news is that such patience is repaid many times over. And so the discussion in this section is merely a beginning, helping you on the way to a thorough understanding of the equations.

Here's a preview of the ways we'll delve more deeply into the equations later in the chapter: I'll [give a short proof of the equations]( http://neuralnetworksanddeeplearning.com/chap2.html#proof_of_the_four_fundamental_equations_ (optional)), which helps explain why they are true; we'll [restate the equations](http://neuralnetworksanddeeplearning.com/chap2.html#the_backpropagation_algorithm) in algorithmic form as pseudocode, and [see how](http://neuralnetworksanddeeplearning.com/chap2.html#the_code_for_backpropagation) the pseudocode can be implemented as real, running Python code; and, in [the final section of the chapter](http://neuralnetworksanddeeplearning.com/chap2.html#backpropagation_the_big_picture), we'll develop an intuitive picture of what the backpropagation equations mean, and how someone might discover them from scratch. Along the way we'll return repeatedly to the four fundamental equations, and as you deepen your understanding those equations will come to seem comfortable and, perhaps, even beautiful and natural.

An equation for the error in the output layer, $\delta^L$: The components of $\delta^L$ are given by $$ \delta_j^L = \frac{\partial C}{\partial a_j^L} \sigma'(z_j^L). $$ This is a very natural expression. The first term on the right, $\frac{\partial C}{\partial a_j^L}$, just measures how fast the cost is changing as a function of the $j^{\text{th}}$ output activation. If, for example, $C$ doesn't depend much on a particular output neuron, $j$, then $\delta_j^L$ will be small, which is what we'd expect. The second term on the right, $\sigma'(z_j^L)$, measures how fast the activation function $ \sigma $ is changing at $ z_j^L $. Notice that everything in (BP1) is easily computed. In particular, we compute $z_j^L$ while computing the behaviour of the network, and it's only a small additional overhead to compute $\sigma'(z_j^L)$. The exact form of $\frac{\partial C}{\partial a_j^L}$ will, of course, depend on the form of the cost function. However, provided the cost function is known there should be little trouble computing $\frac{\partial C}{\partial a_j^L}$. For example, if we're using the quadratic cost function then $C = \frac{1}{2} \sum_j (y_j - a_j^L)^2 $, and so $\frac{\partial C}{\partial a_j^L} = (a_j^L - y_j)$, which obviously is easily computable. Equation (BP1) is a componentwise expression for $\delta^L$. It's a perfectly good expression, but not the matrix-based form we want for backpropagation. However, it's easy to rewrite the equation in a matrix-based form, as $$ \delta^L = \nabla_a C \odot \sigma'(z^L). $$
Here, $\nabla_a C$ is defined to be a vector whose components are the partial derivatives $\frac{\partial C}{\partial a_j^L}$. You can think of $\nabla_a C$ as expressing the rate of change of $C$ with respect to the output activations. It's easy to see that Equations (BP1a) and (BP1) are equivalent, and for that reason from now on we'll use (BP1) interchangeably to refer to both equations. As an example, in the case of the quadratic cost we have $\nabla_a C = (a^L - y)$, and so the fully matrix-based form of (BP1) becomes $$ \delta^L = (a^L - y) \odot \sigma'(z^L). $$ As you can see, everything in this expression has a nice vector form, and is easily computed using a library such as Numpy. **An equation for the error $\delta^l$ in terms of the error in the next layer, $\delta^{l+1}$:** In particular $$ \delta^l = ((w^{l+1})^T \delta^{l+1}) \odot \sigma'(z^l), $$ where $(w^{l+1})^T$ is the transpose of the weight matrix $w^{l+1}$ for the $(l + 1)^{\text{th}}$ layer. This equation appears complicated, but each element has a nice interpretation. Suppose we know the error $\delta^{l+1}$ at the $l + 1^{\text{th}}$ layer. When we apply the transpose weight matrix, $(w^{l+1})^T$, we can think intuitively of this as moving the error backward through the network, giving us some sort of measure of the error at the output of the $l^{\text{th}}$ layer. We then take the Hadamard product $\odot \sigma'(z^l)$. This moves the error backward through the activation function in layer $l$, giving us the error $\delta^l$ in the weighted input to layer $l$.

By combining (BP2) with (BP1) we can compute the error $\delta^l$ for any layer in the network. We start by using (BP1) to compute $\delta^L$, then apply Equation (BP2) to compute $\delta^{L-1}$, then Equation (BP2) again to compute $\delta^{L-2}$, and so on, all the way back through the network. **An equation for the rate of change of the cost with respect to any bias in the network:** In particular: $$ \frac{\partial C}{\partial b_j^l} = \delta_j^l. $$ That is, the error $\delta_j^l$ is exactly equal to the rate of change $\frac{\partial C}{\partial b_j^l}$. This is great news, since (BP1) and (BP2) have already told us how to compute $\delta_j^l$. We can rewrite (BP3) in shorthand as $$ \frac{\partial C}{\partial b} = \delta, $$ where it is understood that $\delta$ is being evaluated at the same neuron as the bias $b$. **An equation for the rate of change of the cost with respect to any weight in the network:** In particular: $$ \frac{\partial C}{\partial w_{jk}^l} = a_k^{l-1} \delta_j^l. $$ This tells us how to compute the partial derivatives $\frac{\partial C}{\partial w_{jk}^l}$ in terms of the quantities $\delta^l$ and $a^{l-1}$, which we already know how to compute. The equation can be rewritten in a less index-heavy notation as$$ \frac{\partial C}{\partial w} = a_{\text{in}} \delta_{\text{out}}, $$ where it's understood that $a_{\text{in}}$ is the activation of the neuron input to the weight $w$, and $\delta_{\text{out}}$ is the error of the neuron output from the weight $w$. Zooming in to look at just the weight $w$, and the two neurons connected by that weight, we can depict this as:
![[Pasted image 20250112175445.png|182]]
A nice consequence of Equation (32) is that when the activation $a_{\text{in}}$ is small, $a_{\text{in}} \approx 0$, the gradient term $\frac{\partial C}{\partial w}$ will also tend to be small. In this case, we'll say the weight *learns slowly*, meaning that it's not changing much during gradient descent. In other words, one consequence of (BP4) is that weights output from low-activation neurons learn slowly. 

There are other insights along these lines which can be obtained from (BP1)-(BP4). Let's start by looking at the output layer. Consider the term $\sigma'(z_j^L)$ in (BP1). Recall from the graph of the sigmoid function in the last chapter that the $\sigma$ function becomes very flat when $\sigma(z_j^L)$ is approximately 0 or 1. When this occurs we will have $\sigma'(z_j^L) \approx 0$. And so the lesson is that a weight in the final layer will learn slowly if the output neuron is either low activation ($\approx 0$) or high activation ($\approx 1$). In this case it's common to say the output neuron has saturated and, as a result, the weight has stopped learning (or is learning slowly). Similar remarks hold also for the biases of output neuron. 

We can obtain similar insights for earlier layers. In particular, note the $\sigma'(z^l)$ term in (BP2). This means that $\delta_j^l$ is likely to get small if the neuron is near saturation. And this, in turn, means that any weights input to a saturated neuron will learn slowly*. 

Summing up, we've learnt that a weight will learn slowly if either the input neuron is low-activation, or if the output neuron has saturated, i.e., is either high- or low-activation.

None of these observations is too greatly surprising. Still, they help improve our mental model of what's going on as a neural network learns. Furthermore, we can turn this type of reasoning around. The four fundamental equations turn out to hold for any activation function, not just the standard sigmoid function (that's because, as we'll see in a moment, the proofs don't use any special properties of $\sigma$). And so we can use these equations to design activation functions which have particular desired learning properties. As an example to give you the idea, suppose we were to choose a (non-sigmoid) activation function $\sigma$ so that $\sigma'$ is always positive, and never gets close to zero. That would prevent the slow-down of learning that occurs when ordinary sigmoid neurons saturate. Later in the book we'll see examples where this kind of modification is made to the activation function. Keeping the four equations (BP1)-(BP4) in mind can help explain why such modifications are tried, and what impact they can have. 

**Summary: the equations of backpropagation** $$ \delta^L = \nabla_a C \odot \sigma'(z^L) $$ $$ \delta^l = ((w^{l+1})^T \delta^{l+1}) \odot \sigma'(z^l) $$ $$ \frac{\partial C}{\partial b_j^l} = \delta_j^l $$ $$ \frac{\partial C}{\partial w_{jk}^l} = a_k^{l-1} \delta_j^l $$

### Problem
- **Alternate presentation of the equations of backpropagation:** I've stated the equations of backpropagation (notably (BP1) and (BP2)) using the Hadamard product. This presentation may be disconcerting if you're unused to the Hadamard product. There's an alternative approach, based on conventional matrix multiplication, which some readers may find enlightening. 1. Show that (BP1) may be rewritten as $$ \delta^L = \Sigma'(z^L) \nabla_a C, $$ where $\Sigma'(z^L)$ is a square matrix whose diagonal entries are the values $\sigma'(z_j^L)$, and whose off-diagonal entries are zero. Note that this matrix acts on $\nabla_a C$ by conventional matrix multiplication. 2. Show that (BP2) may be rewritten as $$ \delta^l = \Sigma'(z^l) (w^{l+1})^T \delta^{l+1}. $$ 3. By combining observations (1) and (2) show that $$ \delta^l = \Sigma'(z^l) (w^{l+1})^T \ldots \Sigma'(z^{L-1}) (w^L)^T \Sigma'(z^L) \nabla_a C. $$ For readers comfortable with matrix multiplication this equation may be easier to understand than (BP1) and (BP2). The reason I've focused on (BP1) and (BP2) is because that approach turns out to be faster to implement numerically.