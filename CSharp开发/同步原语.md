---
title: "[[同步原语]]"
type: Reference
status: done
Creation Date: 2025-09-05 15:19
tags:
---
在多线程环境中，多个线程可能会同时访问和修改同一个共享资源（例如，一个变量、一个文件、一块内存）。如果没有适当的控制，这种情况会导致所谓的“竞态条件” (Race Condition)，从而产生不可预测的、错误的结果。

**同步原语**就是操作系统或编程语言提供的一些特殊的工具或机制，用于协调和管理多个线程的执行顺序，确保在任何时刻只有一个（或有限个）线程能够访问关键的共享资源。它们就像是多线程世界里的“交通信号灯”，指挥着线程们有序地、安全地通过共享资源的“十字路口”。

lock、Mutex 和 Semaphore 就是几种最常见的同步原语。

## 1. lock (在 C# 中是 lock 关键字)

lock 是最简单、最常用的一种同步原语，也称为“监视器锁” (Monitor Lock)。它用于保护一段代码块，确保在任何时刻，只有一个线程可以进入并执行这段代码。

**工作原理**：  
lock 关键字需要一个引用类型的对象作为“钥匙”。当一个线程到达 lock 语句时，它会尝试获取这个“钥匙”。
- 如果“钥匙”可用（没有其他线程持有），该线程就会拿到“钥匙”，进入 lock 代码块执行。执行完毕或发生异常退出代码块时，它会自动释放这把“钥匙”。
- 如果“钥匙”已经被其他线程持有，那么当前线程就会被**阻塞**（暂停执行），在此处排队等待，直到持有“钥匙”的线程释放它为止。
    
**核心特性**：
- **轻量级**：在单进程内部使用，性能开销相对较低。
- **范围锁定**：它保护的是一段代码逻辑，而不是一个对象本身。
- **非递归锁**：同一个线程不能重复获取同一个锁，否则会造成死锁（但在C#中，lock 关键字内部实现的 Monitor 是可重入的，即同一线程可以多次进入同一个锁，这避免了递归调用导致的死锁）。
- **进程内**：lock 只在同一个应用程序进程内有效，无法用于跨进程的线程同步。
    
**使用规范**：
- 通常会创建一个私有的、只读的 object 实例作为锁对象。
- 避免锁定 this、typeof(MyClass) 或字符串等可能被外部代码锁定的公共对象，以防死锁。
    
**示例代码**：
```csharp
public class BankAccount
{
    private readonly object balanceLock = new object(); // 1. 创建私有锁对象
    private decimal balance;

    public void Deposit(decimal amount)
    {
        lock (balanceLock) // 2. 尝试获取锁
        {
            // 这段代码块是线程安全的
            // 在任何时刻只有一个线程能执行这里的代码
            balance += amount;
        } // 3. 离开代码块时，锁被自动释放
    }

    public void Withdraw(decimal amount)
    {
        lock (balanceLock)
        {
            balance -= amount;
        }
    }
}
```
## 2. Mutex (互斥锁)

Mutex 是 "Mutual Exclusion" (互斥) 的缩写。它和 lock 非常相似，都用于确保只有一个线程能访问某个资源。但 Mutex 功能更强大，也更“重”。

**工作原理**：  
线程需要先调用 WaitOne() 方法来请求获取 Mutex。
- 如果 Mutex 未被任何线程拥有，请求的线程将获得所有权，WaitOne() 方法立即返回。
- 如果 Mutex 已被其他线程拥有，当前线程将被阻塞，直到 Mutex 被释放。
- 当线程完成对共享资源的操作后，必须调用 ReleaseMutex() 方法来释放所有权，以便其他等待的线程可以获取它。
    
**核心特性**：
- **跨进程同步**：这是 Mutex 与 lock 最大的区别。Mutex 是一个系统级的资源，可以被命名。不同进程中的线程可以通过同一个名字来获取这个 Mutex，从而实现跨进程间的线程同步。
- **重量级**：因为是系统级的，它的创建和使用开销比 lock 要大得多。
- **需要手动释放**：必须在 finally 块或使用 using 语句来确保 ReleaseMutex() 总能被调用，否则如果持有锁的线程异常退出，锁可能不会被释放，导致其他线程永久等待（死锁）。
    
**适用场景**：
- 需要同步不同进程间的线程时（例如，确保一个应用程序只有一个实例在运行）。
- 在同一个进程内，如果你需要 WaitHandle 的功能（例如，与 WaitAll 或 WaitAny 结合使用）。
    
**示例代码 (单实例应用程序)**：
```csharp
using System.Threading;
using System;
class SingleInstanceApp
{
    private static Mutex mutex = null;

    static void Main()
    {
        const string appName = "MyAppName";
        bool createdNew;

        // 尝试创建一个命名的Mutex
        mutex = new Mutex(true, appName, out createdNew);

        // 如果createdNew是false，说明同名的Mutex已经存在
        // 意味着已经有一个实例在运行了
        if (!createdNew)
        {
            Console.WriteLine("应用程序已经在运行了！");
            return;
        }

        // 正常运行程序逻辑
        Console.WriteLine("应用程序启动成功。");
        Console.ReadKey();

        // 应用程序退出时释放Mutex
        mutex.ReleaseMutex();
    }
}
```
## 3. Semaphore (信号量)
Semaphore 是一个更通用的同步原语。它不像 lock 和 Mutex 那样只允许一个线程进入，而是**允许多个线程（不超过一个最大数量）同时访问一个资源池**。

**工作原理**：  
Semaphore 内部维护一个计数器。
- 当一个线程想访问资源时，它会调用 WaitOne() 方法。这个方法会使计数器的值减 1。
- 如果计数器的值在减 1 后仍然大于或等于 0，那么该线程可以继续执行。
- 如果计数器的值为 0，那么再有线程调用 WaitOne() 时，该线程就会被阻塞，直到有其他线程释放信号量。
- 当一个线程使用完资源后，它必须调用 Release() 方法，这会使计数器的值加 1，可能会唤醒一个正在等待的线程。
    
**核心特性**：
- **资源池管理**：完美适用于管理有限数量的资源，例如数据库连接池、线程池或有限的许可。
- **计数控制**：允许你精确控制并发访问某个资源的线程数量。
- **跨进程**：与 Mutex 类似，Semaphore 也可以命名并在进程间共享。
    
**适用场景**：
- 限制对特定资源的并发访问数量，以防止系统过载。例如，一个服务器程序可能只允许最多 10 个线程同时处理文件下载。
- 生产者-消费者问题中，控制对缓冲区的访问。
    
**示例代码 (模拟下载管理器)**：
```csharp
using System.Threading;
using System;
public class DownloadManager
{
    // 创建一个信号量，初始计数为3，表示最多允许3个并发下载
    private static SemaphoreSlim downloaderPool = new SemaphoreSlim(3);

    public static void DownloadFile(string url)
    {
        Console.WriteLine($"[{Thread.CurrentThread.ManagedThreadId}] 正在等待下载 {url}...");

        downloaderPool.Wait(); // 请求一个下载许可（计数器-1）

        try
        {
            Console.WriteLine($"[{Thread.CurrentThread.ManagedThreadId}] 开始下载 {url}...");
            Thread.Sleep(2000); // 模拟下载过程
            Console.WriteLine($"[{Thread.CurrentThread.ManagedThreadId}] 完成下载 {url}。");
        }
        finally
        {
            downloaderPool.Release(); // 释放下载许可（计数器+1）
            Console.WriteLine($"[{Thread.CurrentThread.ManagedThreadId}] 释放了一个下载槽位。");
        }
    }
}
```