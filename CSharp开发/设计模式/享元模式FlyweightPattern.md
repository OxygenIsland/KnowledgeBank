享元模式（Flyweight Pattern）是一种结构型设计模式，它旨在通过共享尽可能多的对象来有效地支持大量细粒度的对象。在享元模式中，共享的对象通常被称为“享元”（flyweight），而非共享的部分则被称为“外部状态”（extrinsic state）。
## 背景
在某些情况下，应用程序可能需要创建大量的对象实例，而这些对象之间有很多共同之处，比如拥有相同的属性或者方法。传统的做法是为每个对象创建一个独立的实例，但这种方式可能会导致内存消耗过高。
享元模式通过共享尽可能多的对象来解决这个问题，从而节省内存和提高性能。它的核心思想是将对象的状态划分为内部状态和外部状态。内部状态是可以共享的部分，而外部状态则是不可共享的部分。
### 优缺点
**优点**：
- 节省内存：通过共享对象，可以大大减少内存消耗。
- 提高性能：减少了对象的创建和销毁次数，从而提高了系统的性能。
**缺点**：
- 需要对外部状态进行合理的管理，否则可能会导致线程安全问题。
- 在某些情况下，过多的共享可能会导致系统的复杂性增加。
### 应用场景
享元模式适用于以下情况：
- 系统中存在大量的相似对象，这些对象的内部状态相对稳定，可以共享。
- 对象的大部分状态可以被外部状态替代，而外部状态可以在对象被创建之后再进行修改。
- 系统需要频繁地创建和销毁对象，但又不希望因此造成大量的内存开销。
- 
## Participants
![[Pasted image 20240512185416.png|500]]
1. **Flyweight（享元）**：该角色是一个接口或者抽象类，声明了一个操作，通过这个操作可以接受并作用于外部状态。

2. **ConcreteFlyweight（具体享元）**：实现了Flyweight接口，表示可以共享的具体享元对象。具体享元对象中保存了内部状态，但外部状态需要通过参数传递进来。
    
3. **UnsharedConcreteFlyweight（非共享具体享元）**：并不是所有的享元对象都可以被共享，如果对象的外部状态不能被共享，那么它就需要独立地被创建。
    
4. **FlyweightFactory（享元工厂）**：负责创建和管理享元对象。它维护一个享元池（Flyweight Pool），用于存储已经创建的享元对象，并根据需要返回已存在的享元对象或者创建新的享元对象。
