---
title: "[[3.一些设计原则]]"
type: Literature
status: done
Creation Date: 2023-10-09 12:24
tags: 
---
## 单一职责原则
>“一个类而言，应该仅有一个引起它变化的原因[ASD]”

以手机里的俄罗斯方块游戏的开发为例。
首先方块下落动画的原理是画四个小方块，擦掉，然后再在下一行画四个方块。不断地绘出和擦掉就形成了动画，所以应该要有画和擦方块的代码。然后左右键实现左移和右移，下键实现加速，上键实现旋转，这其实都应该是函数，当然左右移动需要考虑碰撞的问题，下移需要考虑堆积和消层的问题。”

如果就用 WinForm 的方式开发，如何开发呢？
先建立一个窗体 Form，然后加一个用于游戏框的控件，比如 Panel 或者 PictureBox，一个按钮 Button 来控制‘开始’，最后再放一个 Timer 控件用于分时动画的编程。写代码当然就是编写 Timer_Tick 事件来绘出和擦除”
![[Screen Shot 2023-10-08 at 20.08.36.png]]
将所有的代码都写在了 Form 1. Cs 这个类里，是不合理的
如果现在要写的是手机版的俄罗斯方块程序，即 Pocket PC 或者 Windows CE 上运行的程序，它们可以安装. NET 框架的精简版，运行 C#语言编写的应用程序 ，但 PC 上的普通 WinForm 界面的程序不能使用。那这个代码的复用性就不是很好，只能Copy 过去，再针对代码做些改进。
但这当中，下落、旋转、碰撞判断、移动、堆积这些游戏逻辑是始终没变的。这些都是和游戏有关的逻辑，和界面如何表示没有什么关系，没必要写在一起

如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏[ASD] 。==事实上，你完全可以找出哪些是界面，哪些是游戏逻辑，然后进行分离。==

软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离[ASD] 。==其实要去判断是否应该分离出类来，也不难，那就是如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责[ASD] ，就应该考虑类的职责分离。==

mvc设计模式就是这一原则的一个很好的实践，可以参见一下pureMVC，这个框架职责的划分是十分细致的。

## 开放-封闭原则
开发和封闭看似是互为对立面，但其实，这个原则是指对于扩展是开放的（Open for extension），对于更改是封闭的（Closed for modification）

开放-封闭原则的意思就是说，我们在设计的时候，时刻要考虑，尽量让这个类是足够好，写好了就不要去修改了，如果新需求来，我们增加一些类就完事了，原来的代码能不动则不动。但事实上，绝对的对修改关闭是不可能的。无论模块是多么的‘封闭’，都会存在一些无法对之封闭的变化。

既然不可能完全封闭，我们就必须对于设计的模块应该对哪种变化封闭做出选择。我们必须先猜测出最有可能发生的变化种类，然后构造抽象来隔离那些变化。举个例子来说，我们设计的类中某个对象可能存在未知的变化，那我们就用一个抽象类或者接口来封装这个对象，在这个类中引用这个对象的抽象形式，这样一来，就算这个对象发生了变化，这个类也不会感知到。

开放-封闭原则是面向对象设计的核心所在。遵循这个原则可以带来面向对象技术所声称的巨大好处，也就是可维护、可扩展、可复用、灵活性好。开发人员应该仅对程序中呈现出频繁变化的那些部分做出抽象，然而，对于应用程序中的每个部分都刻意“地进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要

## 依赖倒转原则
依赖倒转原则，是指==抽象不应该依赖细节，细节应该依赖于抽象==，说白了就是要[[面向接口编程]]，不要对实现编程。
- 高层模块不应该依赖底层模块。两个都应该依赖抽象。
- 抽象不应该依赖细节。细节应该依赖抽象。
### 何为“倒转”
“ 为什么要叫倒转呢?” 
面向过程的开发时，为了使得常用代码可以复用， 一般都会把这些 常用代码写成许许多多函数的程序库，这样我们在做新项目时，去调用这些低层的函数就可以了。比如 我们做的项目大多要访问数据库，所以我们就把访问数据库的代码写成了函数，每次做新项目时就去调 用这些函数。这也就叫做高层模块依赖低层模块。
![[Pasted image 20250301112143.png|400]]
这样做会带来一个问题。
我们要做新项目时，发现业务逻辑的高层模块都是一样的，但客户却希望使 用不同的数据库或存储信息方式，这时就出现麻烦了。我们希望能再次利用这些高层模块，但高层模块 都是与低层的访问数据库绑定在 一起的，没办法复用这些高层模块，这就非常糟糕了。

就像PC里如果CPU、内存、硬盘都需要依赖具体的主板，主板一坏，所有的部件就都没用了，这显然不合理。反过来，如果内存坏了，也不应该造成其他部件不能用才对。而如果不管高层模块还是低层模块， 它们都依赖于抽象，具体一点就是接口或抽象类，只要接口是稳定的，那么任何一个的更改都不用担心 其他受到影响，这就使得无论高层模块还是低层模块都可以很容易地被复用。这才是最好的办法。

那么为什么依赖了抽象的接口或抽象类，就不怕更改呢?

因为我们可以通过里氏代换原则进行替换
>里氏代换原则
>翻译一下就是一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。也就是说，在软件里面，把父类都替换成它的子类，程序的行为没有变化，简单地说，子类型必须能够替换掉它们的父类型。

下图可以帮你更好的理解依赖倒转原则
![[Pasted image 20250301113306.png|375]]

## 迪米特法则
![[Pasted image 20250503093415.png|500]]
迪米特法则首先强调的前提是在类的结构设计上，每一个类都应当尽量降低成员的访问权限[J&DP]，也就是说，一个类包装好自己的private状态，不需要让别的类知道的字段或行为就不要公开。需要公开的字段，通常就用属性来体现了。这也是封装的思想。
在程序设计时，类之间的耦合越弱，越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及。也就是说，信息的隐藏促进了软件的复用。”