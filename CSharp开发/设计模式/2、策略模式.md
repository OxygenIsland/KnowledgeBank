> 面向对象的编程，并不是类越多越好，类的划分是为了封装，但分类的基础是抽象，具有相同属性和功能的对象的抽象集合才是类

利用简单工厂模式来完成一个商场收银软件，营业员根据客户所购买商品的单价和数量，向客户收费，并增加打折、返利等功能，给客户优惠
![[Pasted image 20230823205456.png]]
可以看到虽然类图与第一节的简单工厂模式不同，但是二者的本质是一样的，使用多态的特性，根据一个父类实例就可以调用不同子类的方法。CashFactory 类的实现代码如下
```csharp
class CashFactory//收费对象生成工厂
{
	public static CashSuper createCashAccept(string type)
	{
		public CashSuper cs = null;
		switch (type)//根据条件返回相应的对象
		{
			case "正常收费"：
				cs = new CashNormal();
				break;
			case "满300返100"：
				CashReturn crl = new CashReturn("300", "100");
				cs = crl;
				break;
			case "打8折"：
				CashRebate cr2 = new CashRebate("0.8");
				cs = cr2;
				break;
		}
		return cs;
	}
}
```
简单工厂模式只是解决对象的创建问题，而且工厂本身包括了所有的收费方式，每次维护或扩展收费方式都要改动这个工厂，以致代码需重新编译部署。

策略模式（Strategy）
策略模式定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。
![[Pasted image 20230909225657.png]]
Strategy 类，定义所有支持的算法的公共接口
```csharp
//抽象算法类
abstract class Strategy
{
    //算法方法
    public abstract void AlgorithmInterface（）;
}
```
ConcreteStrategy，封装了具体的算法或行为，继承于 Strategy
```csharp
//具体算法A
class ConcreteStrategyA : Strategy
{
    //算法A实现方法
    public override void AlgorithmInterface（）
    {
        Console.WriteLine（"算法A实现"）;
    }
}
//具体算法B
class ConcreteStrategyB : Strategy
{
    //算法B实现方法
    public override void AlgorithmInterface（）
    {
        Console.WriteLine（"算法B实现"）;
    }
}
//具体算法C
class ConcreteStrategyC : Strategy
{
    //算法C实现方法
    public override void AlgorithmInterface（）
    {
        Console.WriteLine（"算法C实现"）;
    }
}
```
Context，用一个 ConcreteStrategy 来配置，维护一个对 Strategy 对象的引用。
```csharp
class Context
{
	Strategy strategy;
	public Context(Strategy strategy)//初始化时，传入具体的策略对象
	{
		this.strategy = strategy;
	}
	public void ContextInterface()//根据具体的策略对象，调用其算法的方法
	{
		strategy.AlgorithmInterface();
	}
}
```
下面是策略模式的实现
![[Pasted image 20230909231021.png]]
```csharp
public class CashContext
{
	public CashSuper cashSuper;
	public CashContext(CashSuper cashSuper)
	{
		this.cashSuper = cashSuper;
	}
	public void ContextInterface()
	{
		cashSuper.AlgorithmInterface();//利用多态的特性，进行函数调用
	}
}
abstract class CashSuper
{
	public abstract void AlgorithmInterface();
}
public class CashNormal : CashSuper
{
	public override AlgorithmInterface()
	{
		Console.WriteLine（"算法A实现"）;
	}
}
//其他的算法类和上述类似，不再赘述
```
![[Pasted image 20230910002412.png]]
简单模仿策略模式之后，出现了一个老问题，即在客户端去判断用哪一个算法！
有没有什么好办法，把这个判断的过程从客户端程序转移走呢？之前通过简单工厂是可以转移的，简单工厂不一定要是一个单独的类，可以与策略模式的 Context 结合一下，代码如下
```csharp
class CashContext
{
	public CashSuper cs = null;
	public CashContext(string type)
	{
		switch (type)//根据条件返回相应的对象
		{
			case "正常收费"：
				cs = new CashNormal();
				break;
			case "满300返100"：
				cs = new CashReturn("300", "100");
				break;
			case "打8折"：
				cs = new CashRebate("0.8");
				break;
		}
	}
	public double GetResult(double money)
	{
		return cs.acceptCash(money);
	}
}
```
小结一下，所谓策略模式，只是在 CashSuper 上面进行了再次的封装，当有不同于 CashSuper 的策略类需要添加时，只需要添加该类以及修改 CashContext 和 CashFactory 中相应的部分就可以了，其他代码则不需要改动。

将策略模式与简单工厂的客户端代码对比
```csharp
//简单工厂模式的用法
CashSuper csuper = CashFactory.createCashAccept(cbxType.SelectedItem.ToString());
...=csuper.GetResult(...)
//策略模式与简单工厂结合的用法
CashContext csuper =new CashContext(cbxType.SelectedItem.ToString());
...=csuper.GetResult(...);
```
简单工厂模式需要让客户端认识两个类，CashSuper 和 CashFactory，而策略模式与简单工厂结合的用法，客户端就只需要认识一个类 CashContext 就可以了。耦合更加降低。”
在客户端实例化的是 CashContext 的对象，调用的是 CashContext 的方法 GetResult，这使得具体的收费算法彻底地与客户端分离。连算法的父类 CashSuper 都不让客户端认识了。

回过头来反思一下策略模式，策略模式是一种定义一系列算法的方法，从概念上来看，所有这些算法完成的都是相同的工作，只是实现不同，它可以以相同的方式调用所有的算法，减少了各种算法类与使用算法类之间的耦合

策略模式的 Strategy 类层次为 Context 定义了一系列的可供重用的算法或行为。继承有助于析取出这些算法中的公共功能。对于打折、返利或者其他的算法，其实都是对实际商品收费的一种计算方式，通过继承，可以得到它们的公共功能,，即获得计算费用的结果 GetResult，这使得算法间有了抽象的父类 CashSuper。
另外一个策略模式的优点是简化了单元测试，因为每个算法都有自己的类，可以通过自己的接口单独测试
“每个算法可保证它没有错误，修改其中任一个时也不会影响其他的算法。这真的是非常好。”