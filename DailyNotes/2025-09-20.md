---
title: "[[2025-09-20]]"
type: Fleeting
status: done
Creation Date: 2025-09-20 17:19
Tags:
---
## Today's Agency
> [!todo]+ 今日待做
> - [ ] 1、收集一个笑话
> - [ ] 2、拍一张照片
> - [ ] 3、每天写点东西，感悟、心得、日记、知识整理、都可以
> - [ ] 4、读点英文资料
> - [ ] 5、整理一个微信文件传输助手里的视频
> - [ ] 6、每天要收集一个就业、从业相关的知识

## What happened today?
- 17:20 - 为什么不同设备的操作手感是不一样的，虚拟摇杆与物理摇杆的操控手感一致
1、输入的处理方式不同
- 不同的设备，其摇杆的行程的物理特性和输出信号范围可能存在差异，就会导致手感不一致。
    
- **例如**:
    
    - 某些手柄的摇杆物理行程更长，达到最大值需要推动更多距离。
        
    - 不同手柄的输出信号可能不是完美的 [-1, 1] 范围，或者静止时无法完全归零。
        
    - 摇杆的圆形或方形物理限制区域（gated area）不同，导致斜向移动时的最大速度矢量不一致。
#### 2. 死区 (Deadzone) 的处理不当

- **问题描述**: “死区”是指摇杆中心附近一个微小的区域，在此区域内的移动输入会被忽略。这是为了防止因摇杆物理磨损或制造公差导致的“漂移”（即手不碰摇杆，但仍有微小输入）。不同手柄的物理漂移程度不同，因此需要的死区大小也不同。如果你的代码中使用了统一的、固定的死区值，可能会导致：
    
    - **死区太小**: 漂移严重的手柄会无法稳定停住。
        
    - **死区太大**: 响应灵敏的手柄会感觉“迟钝”，需要推动一段距离才有反应。
        
- **Unity的默认行为**: Unity的旧版输入管理器有一个全局的死区设置，但这个“一刀切”的方案往往无法完美适配所有设备。
    

#### 3. 灵敏度曲线 (Sensitivity Curve) 与响应曲线 (Response Curve) 不统一

- **问题描述**: 摇杆从中心推到边缘的过程中，输入值如何从0变化到1（或-1），这个映射关系就是响应曲线。线性曲线意味着推动距离和输出值成正比，但很多游戏会使用非线性曲线（如指数曲线）来实现更精细的微操（中心区域变化慢）和快速的大范围转向（边缘区域变化快）。如果你的代码中没有对不同手柄的输入进行归一化处理，并应用统一的响应曲线，手感就会千差万别。
    
- **例如**: A手柄的原始数据在中心区域变化很快，而B手柄变化很慢。如果不加处理，用户会感觉A手柄“太贼”，B手柄“太木”。


- **（可选）手柄校准功能**: 对于要求极高的应用，可以像很多模拟飞行游戏一样，提供一个手柄校准向导。引导用户将摇杆推到各个极限位置，并记录下最大/最小值和中心点，从而动态地计算出最适合该手柄的死区和输入范围。