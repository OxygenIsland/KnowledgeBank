## 1.提交和推送。
由于 git 是分布式版本控制工具，存在着本地仓库和远程仓库，我们在本地工作副本进行的编辑，要先提交到本地仓库，再从本地仓库推送到远程仓库。编辑完成后，打开 sourceTree, 可以看到文件的变动已经显示到软件界面，点击暂存所选，类似于勾选要提交的文件。
![[Pasted image 20230802194403.png]]
输入提交注释 [A]新增1，点击提交。
![[Pasted image 20230802194515.png]]
提交完成后，可以看到日志/历史选项卡中已显示提交的版本日志，在 master 分支提交了新增1，不过这个 master 分支是本地仓库的，并不是远程仓库的。从第二张图可以看到远程仓库 github 里还是空白的。
![[Pasted image 20230802194556.png]]
![[Pasted image 20230802194609.png]]
推送。点击推送，勾选将本地 master 分支推送到远程 master 分支，点击推送。
![[Pasted image 20230802194705.png]]
推送完成后，可以看到最新的版本里显示了 master 和 origin/master，这表明本地 master 分支和远程 master 分支是同步的，在一个节点上。登录 GitHub 可以看到仓库里已有提交记录了。如下图。这样本地修改的代码或文件就被同步到了远程仓库，可以被别人拉下来使用。
![[Pasted image 20230802194732.png]]
## 2. 获取和拉取
获取是将远程仓库的代码更新到本地仓库，拉取是将本地仓库的代码更新到本地工作副本。打开 sourceTree,点击获取按钮，如下图
![[Pasted image 20230802194825.png]]
点击确定，可以看到拉取图标那里多了一个蓝底白色的数字1，分支 master 那里也有一个灰色的数字1，并有一个向下的箭头，这表示有一个更新需要拉取到本地工作副本。同时打开版本文件，可以看到 test1.txt 文件中没有第二步增加的123。
![[Pasted image 20230802194903.png]]
一般在实际使用中是不会先点获取，再点拉取的，因为拉代码都是直接一步到位为拉到本地工作副本的。所以直接一个拉取操作就够了。
![[Pasted image 20230802195511.png]]
## 3.创建分支和合并分支
当要新增一个功能，又要保证原始功能的正常的使用，这个时候为了不影响原功能的使用，就可以建立一个分支，在分支上进行新增功能的开发，等到新增的功能测试通过后再把分支合并到主干上。如下图，点击分支，输入新分支名字，以当前工作副本为基础生成一个新的 develop 分支。
![[Pasted image 20230802195631.png]]
点击创建分支，可以看到多了一个 develop 分支，但是这个分支只存在于本地仓库。可以看到最新的日志记录节点上只有 master ， origin/master,develop,所以这个新分支是没有推送到远程仓库的
![[Pasted image 20230802195652.png]]
点击推送，如下图，勾选第一个，将本地 develop 分支推送到远程 develop 分支
![[Pasted image 20230802195712.png]]
点击推送，如下图，可以看到本地 develop 和远程 develop 已经同步了。
![[Pasted image 20230802195736.png]]
在 develop 分支上新增功能，这里是新增了 add func1
![[Pasted image 20230802195803.png]]
在 sourceTree 界面，推送新增的功能到 develop 分支
![[Pasted image 20230802195824.png]]
再提交一条新增记录，如下图。可以看到 develop 分支比 master 分支多了2条提交记录。
![[Pasted image 20230802195848.png]]
![[Pasted image 20230802195855.png]]
功能1和2测试通过，现在要将 develop 分支上新增的两个功能合并到主分支 master 上。将当前分支切换到 master 分支，鼠标移到到 develop 分支，右键，选择合并 develop 至当前分支，也即是主分支。
![[Pasted image 20230802195912.png]]
点击确定
![[Pasted image 20230802195931.png]]
可以看到 master 的本地仓库多了两条需要推送的记录。如图所示的红框内图标2，说明 develop 分支新增的两个功能已合并到本地仓库的 master 分支。
![[Pasted image 20230802195948.png]]
推送合并过来的两个新增功能。可以看到 master 分支已有了新增的两个功能。
![[Pasted image 20230802200009.png]]
## 4.冲突解决
冲突一般是由于两个人同时修改同一文件而造成的。在 GitHub 上修改远程仓库文件模拟一个人操作，sourceTree 本地修改同一文件模拟另一个人操作。
登录 GitHub ，打开 GitTest，编辑 test1.txt 文件
![[Pasted image 20230802200659.png]]
在文件末尾增加内容 code conclick1,点击提交。如下图所示。
![[Pasted image 20230802200722.png]]
![[Pasted image 20230802200732.png]]
打开本地工作副本的 test1.txt 文件，新增内容 code conclick2，如下图：
![[Pasted image 20230802200748.png]]
打开 sourceTree,可以看到本地工作副本有个待提交记录。
![[Pasted image 20230802200803.png]]
推送代码。这个时候你修改完了本地的功能，并不知道远程仓库上也有人提交了该文件的修改。直接推送本地修改，推送本地工作副本到远程仓库，运行完成后会报错，大概是提示本地仓库和远程仓库版本不一致，无法提交，但是本地工作副本的修改却是已经提交到了本地仓库。如下图。
![[Pasted image 20230802200823.png]]
![[Pasted image 20230802200831.png]]
既然提示和远程仓库版本不一致，无法推送，那只能先拉成一致了。点击拉取图标，等执行完，就会出现下图所示。有一个待拉取的图标和一个待推送的图标，并且 test1.txt 文件的图标变成了黄色的感叹号。这个时候文件的冲突就造成了。
![[Pasted image 20230802200850.png]]
冲突文件会把两者的修改以冲突的方式合在一个文件里，等待使用者去处理。那么基本的处理思想是：要么使用其中某一个人的，要么使用两者的组合。
冲突的解决需要一个外部代码对比工具，我这里使用的是 Beyond Compare 4，大家可以自己百度下载安装，然后集成到 sourceTree 软件中。如下图。在外部对比工具中找到 Beyond Compare 4的可执行程序，点击确定。
![[Pasted image 20230802200935.png]]
下面开始使用代码对比工具解决冲突，选中待解决冲突的代码，右键解决冲突，打开外部合并工具。
![[Pasted image 20230802201007.png]]
等待一会，Beyond Compare 4就会被打开。第一块是本地修改的版本，第二块是冲突两者（本地仓库和远程仓库）相同的版本基准，第三块是远程仓库的修改。第四块是冲突处理后的代码。
![[Pasted image 20230802201027.png]]
本次解决冲突是为了合并两者的修改，所以我会把第一块和第三块所做的修改按照正确的逻辑顺序，合到第四块。如下图，点击保存。关闭该对比软件。
![[Pasted image 20230802201045.png]]
切到 sourceTree 界面，可以看到多了一个解决冲突的中间文件，由于冲突已解决，直接右键移除，
![[Pasted image 20230802201102.png]]
可以看到冲突已解决，代码已正确合并。推送该合并。
![[Pasted image 20230802201123.png]]
这样冲突就被解决了
## 5.文件部分提交以及提交的撤销回滚
  有的时候，我们开发了一个 A 功能，未上线，同时又并发开发了 B 功能，B 功能比 A 功能先上线，而且 B 功能和 A 功能修改的是同一个文件，这种情况在上线 B 功能时，SourceTree 就体现出优势了。
  打开本地工作副本，增加文件 activityServiceImpl.java，这个文件没啥特别，就是代码行数很多，方便演示。
  ![[Pasted image 20230802231048.png]]
  打开 SourceTree，推送该文件。
  ![[Pasted image 20230802231102.png]]
  打开新增文件，新增 func1,func2,func3三个功能，
  ![[Pasted image 20230802231122.png]]
  现在的要求是，只提交 func3，不提交 func1和 func2。打开 sourceTree。如下图
  ![[Pasted image 20230802231136.png]]
  右边区域滑到 add func3处，点击暂存区块，该区块就会保存到待提交区。
  ![[Pasted image 20230802231151.png]]
  已暂存文件里是待提交的，未暂存文件里不需要提交的，这样在一个文件里，就可以提交需要提交的，而不需要提交的也可以保留在工作区，等待下次提交
  ![[Pasted image 20230802231206.png]]
  提交推送，如下图。
  ![[Pasted image 20230802231220.png]]
  撤销回滚。在团队协作开发中，有时候提交完代码后，发现提交错了，这个时候，撤销回滚就起了重要作用。
在最新的提交记录上，右键-》回滚提交
![[Pasted image 20230802231241.png]]
![[Pasted image 20230802231247.png]]
可以看到提交历史记录多了一个 Revert  反向提交
![[Pasted image 20230802231306.png]]
打开本地工作副本，看到做的修改已去除
![[Pasted image 20230802231319.png]]
这个时候，反向提交只提到了本地仓库，如需撤销远程仓库的，还需推送到远程仓库
![[Pasted image 20230802231332.png]]
点击推送，可以看到提交的 func3已撤销。如下图。
![[Pasted image 20230802231345.png]]
撤销回滚只能撤销回滚最近的一次提交，并不能回滚到历史某个提交
## 6.回滚版本到某次提交
打开 sourceTree,切换到开发分支
![[Pasted image 20230802231502.png]]
打开本地工作副本 test1.txt 文件，编辑新增 add test1
![[Pasted image 20230802231516.png]]
提交并推送本次新增到远程仓库
![[Pasted image 20230802231536.png]]
打开本地工作副本 test1.txt 文件，编辑新增 add test2
![[Pasted image 20230802231551.png]]
提交并推送本次修改到远程仓库，可以看到最新的历史记录在本地仓库和远程仓库都已有了新增 test1和新增 test2
![[Pasted image 20230802231604.png]]
如果这个时候突然发现前面的两次提交是错误的，现在想回到“提取 release 分支的某次提交到 develop 分支”这个版本。有两种解决方式，第一种是删除掉新增 test1和新增 test2两次提交所加的内容，但是这有个前提，是修改内容很少的情况下才可以采用此方法，否则会陷入无穷无尽的代码比对泥沼。那么第二种方式就是该教程将要讲述的。回退到某个历史版本。
![[Pasted image 20230802231622.png]]
切换到 sourceTree 界面，打开 develop 分支的日志/历史，鼠标选中将要回退到的那个历史提交记录
![[Pasted image 20230802231635.png]]
右键-》重置当前分支到此次提交
![[Pasted image 20230802231648.png]]
在弹窗中使用模式选择强行合并--丢弃所有改动过的工作副本，点击确定
![[Pasted image 20230802231705.png]]
等待重置完，可以看到本地仓库的 develop 分支已回退到 “提取 release 分支的某次提交到 develop 分支”提交。而且本地仓库落后远程仓库两个提交记录。
![[Pasted image 20230802231719.png]]
依然是同样的操作。选中最新的提交历史记录，右键-》重置当前分支到此次提交
![[Pasted image 20230802231736.png]]
这次选的使用模式是软合并 – 保持所有本地改动，点击确定
![[Pasted image 20230802231750.png]]
等待重置完。发现本地仓库开发分支已和远程仓库开发分支同步。这个结果似乎看起来两次重置抵消了一样，代码版本没有发生任何的变化。实际并不是这样，这就是神奇之处，会让你恍然大悟的地方。
![[Pasted image 20230802231807.png]]
切换到文件状态，可以看到本地工作副本多了一个 test1.txt 的改动文件，而且改动文件的内容正好删除了新增 test1和新增 test2两次提交所修改的内容。
![[Pasted image 20230802231823.png]]
那么，剩下的操作只需将这个改动文件提交并推送到远程仓库，是不是就 OK 了？

下面尝试，提交并推送该改动文件。如下图，推送之后的效果。
![[Pasted image 20230802231844.png]]
如下图，可以看出本地工作副本和远程仓库的 add test1 和 add test2内容都被回退掉了。也就是代码版本从内容上回退到了某个历史版本，但是提交历史记录并没有回退。Git 只会增加提交历史记录，是不会回退或删除提交记录的。我们所说的回退都是指的回退内容。
![[Pasted image 20230802231859.png]]
## 7.合并某次提交
在 Git 的实际使用场景中，未必都是很规矩的拉一个分支，开发一个功能，等功能测试完成后，合并到主分支。有很多的场景都是很多人在同一个开发分支上开发，然后按照上线的实际需要，依次去上传自己的功能模块，这个功能模块的提交记录很可能是交叉提交的，那么这时候如何去只合并一个功能到主分支呢？或者是说怎么使用 sourceTree 去合并某次或某几次（不连续）提交到另一个分支？
打开 sourceTree，切换到 develop 分支
![[Pasted image 20230802232034.png]]
打开本地工作副侮侮本，新增 test2.txt 文件吩炼言，并编辑 add func1内容
![[Pasted image 20230802232046.png]]
提交并推送这次新增到远程仓库
![[Pasted image 20230802232100.png]]
打开本地工作副本，编辑 test2.txt 文件，新增 add func2
![[Pasted image 20230802232112.png]]
提交并推送这次修改内容，执行完成后，如下图所示
![[Pasted image 20230802232129.png]]
现在 test2.txt 文件新增的 func1功能由于测试通过，需要先上线，合并到 master 分支。也就是要合并新增 test2.txt 文件  add func1 的提交到 master，而不动“新增 func2”的提交。

切换到 master 分支，可以看到 master 分支落后 develop 分支好多版本了，test2.txt 文件对于 master 分支完全是新增文件怕篇，所以待会合并某次提交到 master 分支的时候，应该不会产生冲突的。下面关键的操作来了。
![[Pasted image 20230802232155.png]]
将当前分支切换到所有分支，如下图红框内
![[Pasted image 20230802232221.png]]
选择待合并的提交记录，右键 – 》遴选
![[Pasted image 20230802232234.png]]
在确认遴选的弹窗中点击是。
![[Pasted image 20230802232248.png]]
执行完后。切换到当前分支，可以看到 master 分支的本地仓库多了一个” 新增 test2.txt 文件  add func1” 的提交历史记录。执行的过程中果然是没有遇到冲突
![[Pasted image 20230802232303.png]]
推送该次合并到 master 分支的远程仓库。这样就完成了，合并某次提交到另一分支的操作。
![[Pasted image 20230802232320.png]]