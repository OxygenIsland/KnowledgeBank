---
title: "[[点云渲染的优化之路]]"
type: Permanent
status: ing
Creation Date: 2025-09-16 11:06
tags:
---
## 1、原始方案
点云数据解析（坐标系转换，计算密集；颜色处理）->分块处理->分帧处理->GameObject实例化->GPU对每个立方体进行处理（顶点处理、光栅化、片元着色、渲染管线）

CPU瓶颈
主线程阻塞: for (int i = 0; i < _pointCount; i++) 一次性处理所有点
GameObject风暴: 10万个点 = 10万个GameObject + 30万个组件
材质状态破坏: 每个立方体独立设置颜色，无法GPU批处理
每个立方体独立设置material.color，Unity无法合批
10万个点 = 10万个DrawCall
GPU性能严重浪费

GPU瓶颈
DrawCall爆炸: 每个GameObject一个DrawCall
几何数据冗余: 相同立方体数据重复传输

## 2、使用mesh api
点云数据解析（坐标系转换，计算密集；颜色处理）->分批处理->批处理器渲染

**CPU 串行解析数据 → CPU 分批打包实例数据 → GPU 并行渲染大量实例**

渲染的核心是分批处理。由于一次 DrawMeshInstanced 调用有实例数量上限（通常是 1023），代码以 _maxInstancesPerBatch 为步长遍历所有点。
1. **创建渲染代理**: CreateInstancedBatch 函数被调用。
    - 它创建一个新的 GameObject (batchObject) 来代表这个批次。
    - 关键一步：它添加了一个 PointCloudBatchRenderer 组件。
    - **数据流动**: Initialize 方法被调用，将这个批次的**立方体 Mesh**、**专用材质**、**变换矩阵数组 matrices** 和**颜色数组 colors** 全部传递并存储在 PointCloudBatchRenderer 实例中。

主要优化点
🚀 性能提升
DrawCall优化: 从10万个降低到约100个（每批1023个实例）
内存优化: 消除大量GameObject和组件创建
GPU利用: 充分利用GPU Instancing并行渲染能力
🔧 实现方式
GPU Instancing: 使用Graphics.DrawMeshInstanced批量渲染
MaterialPropertyBlock: 为每个实例设置独立颜色
分批处理: 解决GPU Instancing的1023实例限制
Mesh合并备选方案: 提供CreateMeshesWithCombining作为备选
📊 预期性能对比

指标	原实现	Mesh优化后	提升倍数
DrawCall	100,000	~100	1000x
内存使用	极高	低	10-50x
帧率	1-5 FPS	30-60 FPS	10-60x
CPU使用率	90%+	<20%	5x+

## 3、使用computerBuffer
点云数据解析（坐标系转换，计算密集；颜色处理）->cpu将点的信息传输到显存中->视锥体剔除->gpu执行渲染
- **CPU/GPU 流动路径**:
    1. **CPU 计算密集区**: 网络 byte[] → 解析为 List\<Vector3> (RAM) → 转换为 List\<Matrix4x4> (RAM)。
    2. **CPU → GPU 数据上传**: List\<Matrix4x4> (RAM) → positionInputBuffer (VRAM)。
    3. **GPU 内部流动**: positionInputBuffer → (Compute Shader 剔除) → positionOutputBuffer + argsBuffer (计数)。
    4. **GPU 内部渲染**: argsBuffer + positionOutputBuffer → 最终像素。