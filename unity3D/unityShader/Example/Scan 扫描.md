---
title: "[[Scan 扫描]]"
type: Literature
status: done
Creation Date: 2024-12-25 10:13
tags:
---
扫描特效是类似一种扫描光线从屏幕上一扫而过的效果，并非3D 游戏中那种以主角为中心发射的扫描脉冲波，我们的效果比较简单，直接看最终效果图：
![[2oAugwaUHt3kiN8Lj0WSB4FnbpRz.gif|148]]   ![[3fubPQZH6hjFMLYOlmdeJcCEDABs.gif|106]]
## 思路分析
其实，如同流光效果一样，整个扫描光线就是一个`从左往右`移动的过程，所以，我们先实现扫描光线一扫而过的效果，再来研究那些不停闪烁的方格该怎么实现。

### 扫描光线
通过观察效果图，我们可以发现，扫描光线其实就是一个水平的uv区域，我们只要定义好这片区域，再给予一个光强就可以了。
首先，我们定义如下两个参数：
```shader
_ScanPos("扫描线位置", Range(0,2)) = 0 
_ScanWidth("扫描线宽度",Range(0,1)) = 1
```
`扫描线位置` 用于定义扫描光线区域的开始位置，`扫描线宽度` 用于定义扫描光线区域的宽度。
如果不太好懂的话，我们看图理解，比如，`_ScanPos=0.5`，`_ScanWidth=0.3` 时，求出的扫描光线区域应该如下图这样，`白色的区域` 便是扫描光线当前所在的区域：
![[Pasted image 20241225102139.png|374]]
**注意：我们只考虑从左往右扫描的过程，如需其他方向，直接旋转图像即可。**
通过敲击几下键盘，我们键入了求出这个区域的代码：
```shader
//区域左边界 
fixed left = scanPos - scanWidth; 
//区域右边界 
fixed right = scanPos; 
//求出区域（即x坐标同时大于左边界、小于右边界） 
//factor 为1时代表当前处在扫描光线区域 
fixed factor = step(left, uv.x) * step(uv.x, right);
```
其中，重点分析一下最后一行
- `uv.x` 是当前像素的 `x` 坐标（通常是归一化后的纹理坐标，在 [0, 1] 范围内）。
- step(a, b) 是一个内置的函数，它返回一个浮动的值（0 或 1），表示 `b` 是否大于或等于 `a`。具体来说：
    - `step(left, uv.x)` 会返回 1 当 `uv.x >= left`，否则返回 0。
    - `step(uv.x, right)` 会返回 1 当 `uv.x <= right`，否则返回 0。
通过这个计算，`factor` 可以作为一个 **布尔条件** 来判断当前像素是否在扫描区域内。
### 扫描光线区域平滑
接下来，我们要将上一步求出的 `扫描光线区域` 平滑一下，使得越往右侧越亮，越往左侧越暗，使用 `smoothstep` 方法可以完美达成我们的目的：
```shader
fixed value = smoothstep(left, right, uv.x);
```
smoothstep 是 Unity Shader 中的一个内置函数，它通常用于进行平滑插值，产生一种平滑过渡效果。函数的定义如下：
```shader
float smoothstep(float edge0, float edge1, float x);
```
- `edge0` 是开始插值的边界。
- `edge1` 是结束插值的边界。
- `x` 是输入的值，它将在 `edge0` 和 `edge1` 之间进行插值。
smoothstep 会根据输入的值 `x` 和给定的边界 `edge0` 和 `edge1`，输出一个平滑的过渡值。具体来说：
- 如果 `x < edge0`，输出 0。
- 如果 `x > edge1`，输出 1。
- 如果 `x` 在 `edge0` 和 `edge1` 之间，它会输出一个平滑的插值值，在 0 和 1 之间过渡，具有 `S` 形曲线效果。
通过这个方法将当前 uv 的 x 坐标使用 `左边界` 和 `右边界` 进行平滑，当 x 坐标小于等于 `左边界` 时，返回0，当 x 坐标大于等于 `右边界` 时，返回1，否则会根据 x 坐标的值在两者之间平滑，如此便可以得到一个完美的平滑区间。
完成这一步之后，我们的大致效果应该是这样的：
![[Pasted image 20241225103524.png|360]]
### 闪烁的方格
接下来是重头戏，那些代表`扫描光线力场`的闪烁的方格该如何实现？
首先，通过观察效果图，我们发现他们拥有`随机性`这一特点，一想到随机，二话不说就可以考虑噪声纹理。
所以，先引入噪声纹理，以及两个参与计算的参数：
```
_NoiseTex("噪声纹理", 2D) = "white" {} 
_ScanIntensity("扫描光线强度", Range(0, 10)) = 5 
_ScanDensity("扫描光线密度", Range(2, 20)) = 5
```
`扫描光线强度` 毋容置疑，就是最终显示的扫描光线区域强度，而 `扫描光线密度`，很明显在这里他的作用就是定义了扫描光线中那些闪烁的方格的大小。
#### 放大 uv 细节，生成方格
```shader
float2 scanUV = round(uv * scanDensity) / scanDensity;
```
这里，将纹理坐标 `uv`（通常是归一化的坐标，范围为\[0, 1]）按一定的“扫描密度”（`scanDensity`）进行四舍五入处理，并将其归一化回到 `[0, 1]` 范围内。通过这种方式，代码实现了一种类似“网格化”或“像素化”的效果。
-  `uv` 是当前像素的纹理坐标，通常是一个归一化的值，范围是 `[0, 1]`，表示当前像素在纹理图像上的相对位置。
    - `uv.x` 和 `uv.y` 的值都在 [0, 1] 范围内。
    - 这个坐标通常是从片段着色器或其他计算中获得的，并用于从纹理中获取颜色或其他信息。
-  `uv * scanDensity`
	- 这一步是将 `uv` 坐标乘以 `scanDensity`，实际上是将纹理坐标 `uv` 放大。  
    - 例如，如果 `scanDensity = 10`，那么将 `uv` 乘以 `10` 后，`uv` 的值就变成了一个较大的数值（比如从 `0.1` 到 `0.9` 变为 `1` 到 `9`）。这意味着我们将纹理坐标放大，增大了像素的范围。如果 `uv = (0.25, 0.75)`，`scanDensity = 10`，则 `uv * scanDensity = (2.5, 7.5)`。
- `round(uv * scanDensity)`
    - 这一步是将放大的坐标值 `uv * scanDensity` 四舍五入到最近的整数。
    - `round` 函数会将每个坐标的值四舍五入到最接近的整数，从而让纹理坐标变得离散。例如：
        - `round(2.5)` 会变成 `3`。
        - `round(7.5)` 会变成 `8`。
     这样，`round` 的作用是将坐标“量化”到一个特定的网格上，而这个网格的大小由 `scanDensity` 决定。
-  `round(uv * scanDensity) / scanDensity`
    - 最后，`round(uv * scanDensity)` 得到的离散坐标被除以 `scanDensity`，这将恢复到原来的尺度（[0, 1] 范围内）。
    - 例如，如果 `round(uv * scanDensity)` 得到了 `(3, 8)`，而 `scanDensity = 10`，则 `scanUV` 会变成 `(3 / 10, 8 / 10)`，即 `(0.3, 0.8)`。
     这一步确保了最终的坐标仍然在 [0, 1] 范围内，但由于之前四舍五入的过程，坐标变得更加离散，类似于在纹理上创建了一个网格或“像素化”效果。
 
使用 `扫描光线密度` 放大 uv 的值，然后 `round` 取整，再除以 `扫描光线密度`，会使得 uv 的细节因放大而丢失。
比如一个 uv 值：0.222，经过上面的放大公式后,他的值被修正为了0.2。也即是说，0.2附近的某一个 uv 区块的值，都会被强制修正为0.2，也即是形成了一个颜色统一的 `方格`。
#### 方格闪烁
我们将每个方格输出的颜色都与噪声数据相乘，即达到了随机输出一个颜色的效果，也即是 `闪烁`：
```shader
float intensity = tex2D(noiseTex, scanUV + float2(_Time.y, _Time.y)).a * scanIntensity;
```
这里的 `intensity` 也即是闪烁的强度。
-  `tex2D(noiseTex, scanUV + float2(_Time.y, _Time.y))`
    - `tex2D(noiseTex, ...)` 是一个用于从纹理 `noiseTex` 中采样的函数。`noiseTex` 是一个纹理采样器（通常是噪声纹理），可以用于生成随机或噪声值。
    - `scanUV` 是前面计算得到的纹理坐标（可能是离散化后的结果，表示扫描区域的坐标）。
    - `float2(_Time.y, _Time.y)` 通过 `float2` 创建一个二维向量，其中两个分量都是 `_Time.y`，即当前时间的 Y 分量。`_Time.y` 是 Unity 中的内置变量，它表示游戏运行的总时间（从启动游戏开始经过的时间，单位为秒）。`_Time.y` 是一个渐变的浮动值，它随时间不断增加。
    - `scanUV + float2(_Time.y, _Time.y)` 表示将 `scanUV` 和基于时间的向量相加，这样做的目的是使得纹理采样的坐标随着时间而变化，通常用于创建随时间变化的动态效果（例如动画、流动的噪声等）。
     例如，假设 `scanUV` 是 `(0.5, 0.5)`，而 `_Time.y` 是 `2.0`，则新的采样坐标是 `(0.5 + 2.0, 0.5 + 2.0)`，即 `(2.5, 2.5)`。通过这种方式，纹理采样坐标会随时间持续变化，从而使噪声效果随时间发生变化。
    - `tex2D(noiseTex, scanUV + float2(_Time.y, _Time.y))` 从 `noiseTex` 纹理中采样，返回纹理坐标 `(scanUV + float2(_Time.y, _Time.y))` 处的颜色值。这里的 `.a` 表示获取纹理颜色的 alpha 通道（透明度通道），通常噪声纹理的 alpha 通道包含了噪声的强度信息。
- `.a`
    - `tex2D` 函数返回的是一个 `float4` 类型的颜色值，其中包含四个分量：`r`、`g`、`b` 和 `a`（分别对应红色、绿色、蓝色和透明度）。
    - `.a` 表示取出该颜色的 **alpha 通道**，即噪声纹理中存储的强度值（假设噪声纹理的 alpha 通道代表噪声强度）。
- `* scanIntensity`
    - `scanIntensity` 是一个控制强度的系数，用于动态调节噪声的影响力。例如，`scanIntensity` 为 `1.0` 时，噪声强度保持不变，而为 `2.0` 时，噪声强度将加倍。
    - 通过将噪声的 alpha 通道值与 `scanIntensity` 相乘，可以调整噪声强度的幅度。
    
- float intensity `
     - 最终计算出的 `intensity` 是一个 `float` 类型的值，表示噪声的强度。这个值是从噪声纹理中提取的 alpha 通道值经过时间变化和强度调节后的结果。
    - `intensity` 的值用于后续的计算，比如控制方格的闪烁强度
### 最终的扫描光线
最后，我们定义一个扫描光线颜色：
```shader
_ScanColor("扫描光线颜色", Color) = (1,1,1,1)
```
将他与之前求得的 `扫描光线区域` 和 `闪烁强度` 相乘，也即是最终的输出颜色：
```shader
color += value * scanColor * intensity * factor;
```
`color` 是一个颜色值，通常是一个 `float4` 类型，表示颜色的 RGBA 值（红色、绿色、蓝色和透明度）。它是正在渲染的像素的最终颜色值。每次计算该像素时，就会更新它的颜色值。
![[Pasted image 20241225110118.png|331]]
**请注意：factor 的值为0或1，即代表了当前 uv 点是否在扫描光线的区域内，所以这里乘以 factor，未在区域内的 uv 点会直接将扫描光线的光强置于0。**
### 扫描动画
接着，要实现扫描动画，使用动画播放器附加到 `扫描光线位置` 属性，不过需要注意的是，这里的动画值范围最好是0-2,：
![[Pasted image 20241225110148.png|267]]
