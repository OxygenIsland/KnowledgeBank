## 1.1 综述
渲染流水线的工作任务在于由一个三维场景出发、生成（或者说渲染）一张 2 维图像
“渲染流程分成 3 个阶段：应用阶段（Application Stage） 、几何阶段（Geometry Stage）、光栅化阶段（Rasterizer Stage）。
  ![[Pasted image 20231015205718.png|500]]
1. 应用阶段
    这个阶段是由应用主导，因此通常由 CPU 负责实现。换句话说，开发者具有这个阶段的绝对控制权。在这一阶段中，开发者有 3 个主要任务：首先，需要准备好场景数据，例如摄像机的位置、视锥体、场景中包含了哪些模型、使用了哪些光源等等；其次，为了提高渲染性能，我们往往需要做一个粗粒度剔除（culling）工作，以把那些不可见的物体剔除出去，这样就不需要再移交给几何阶段进行处理；最后，需要设置好每个模型的渲染状态。这些渲染状态包括但不限于它使用的材质（漫反射颜色、高光反射颜色）、使用的纹理、使用的 Shader 等。这一阶段最重要的输出是渲染所需的几何信息，即渲染图元（rendering primitives） 。通俗来讲，渲染图元可以是点、线、三角面等。这些渲染图元将会被传递给下一个阶段——几何阶段。
2. 几何阶段
    几何阶段用于处理所有和我们要绘制的几何相关的事情。例如，决定需要绘制的图元是什么，怎样绘制它们，在哪里绘制它们。这一阶段通常在 GPU 上进行。几何阶段负责和每个渲染图元打交道，进行逐顶点、逐多边形的操作。几何阶段的一个重要任务就是把顶点坐标变换到屏幕空间中，再交给光栅器进行处理。通过对输入的渲染图元进行多步处理后，这一阶段将会输出屏幕空间的二维顶点坐标、每个顶点对应的深度值、着色等相关信息，并传递给下一个阶段。
3. 光栅化阶段
    这一阶段将会使用上个阶段传递的数据来产生屏幕上的像素，并渲染出最终的图像。这一阶段也是在 GPU 上运行。光栅化的任务主要是决定每个渲染图元中的哪些像素应该被绘制在屏幕上。它需要对上一个阶段得到的逐顶点数据（例如纹理坐标、顶点颜色等）进行插值，然后再进行逐像素处理。
## 1.2 CPU 和 GPU 之间的通信
渲染流水线的起点是 CPU，即应用阶段。应用阶段大致可分为下面 3 个阶段：
（1）把数据加载到显存中。
（2）设置渲染状态。
（3）调用 Draw Call（在本章的最后我们还会继续讨论它）。
### 1 .2.1　把数据加载到显存中
所有渲染所需的数据都需要从硬盘（Hard Disk Drive，HDD）中加载到系统内存（Random Access Memory，RAM）中。然后，网格和纹理等数据又被加载到显卡上的存储空间——显存（Video Random Access Memory，VRAM）中。这是因为，显卡对于显存的访问速度更快，而且大多数显卡对于 RAM 没有直接的访问权利。
![[Pasted image 20231015210654.png|475]]
▲图 1.2　渲染所需的数据（两张纹理以及 3 个网格）从硬盘最终加载到显存中。在渲染时，GPU 可以快速访问这些数据
需要注意的是，真实渲染中需要加载到显存中的数据往往比图 1.2 所示复杂许多。例如，顶点的位置信息、法线方向、顶点颜色、纹理坐标等。
当把数据加载到显存中后，RAM 中的数据就可以移除了。但对于一些数据来说，CPU 仍然需要访问它们（例如，我们希望 CPU 可以访问网格数据来进行碰撞检测），那么我们可能就不希望这些数据被移除，因为从硬盘加载到 RAM 的过程是十分耗时的。
在这之后，开发者还需要通过 CPU 来设置渲染状态，从而“指导”GPU 如何进行渲染工作。
### 1 .2.2　设置渲染状态
什么是渲染状态呢？一个通俗的解释就是，这些状态定义了场景中的网格是怎样被渲染的。例如，使用哪个顶点着色器（Vertex Shader）/片元着色器（Fragment Shader）、光源属性、材质等。如果我们没有更改渲染状态，那么所有的网格都将使用同一种渲染状态。图 2.4 显示了当使用同一种渲染状态时，渲染 3 个不同网格的结果。