## 1.1 综述
渲染流水线的工作任务在于由一个三维场景出发、生成（或者说渲染）一张 2 维图像
“渲染流程分成 3 个阶段：应用阶段（Application Stage） 、几何阶段（Geometry Stage）、光栅化阶段（Rasterizer Stage）。
  ![[Pasted image 20231015205718.png|500]]
1. 应用阶段
    这个阶段是由应用主导，因此通常由 CPU 负责实现。换句话说，开发者具有这个阶段的绝对控制权。在这一阶段中，开发者有 3 个主要任务：首先，需要准备好场景数据，例如摄像机的位置、视锥体、场景中包含了哪些模型、使用了哪些光源等等；其次，为了提高渲染性能，我们往往需要做一个粗粒度剔除（culling）工作，以把那些不可见的物体剔除出去，这样就不需要再移交给几何阶段进行处理；最后，需要设置好每个模型的渲染状态。这些渲染状态包括但不限于它使用的材质（漫反射颜色、高光反射颜色）、使用的纹理、使用的 Shader 等。这一阶段最重要的输出是渲染所需的几何信息，即渲染图元（rendering primitives） 。通俗来讲，渲染图元可以是点、线、三角面等。这些渲染图元将会被传递给下一个阶段——几何阶段。
2. 几何阶段
    几何阶段用于处理所有和我们要绘制的几何相关的事情。例如，决定需要绘制的图元是什么，怎样绘制它们，在哪里绘制它们。这一阶段通常在 GPU 上进行。几何阶段负责和每个渲染图元打交道，进行逐顶点、逐多边形的操作。几何阶段的一个重要任务就是把顶点坐标变换到屏幕空间中，再交给光栅器进行处理。通过对输入的渲染图元进行多步处理后，这一阶段将会输出屏幕空间的二维顶点坐标、每个顶点对应的深度值、着色等相关信息，并传递给下一个阶段。
3. [[Overview of computer graphics#Rasterization 光栅化|光栅化]]阶段
    这一阶段将会使用上个阶段传递的数据来产生屏幕上的像素，并渲染出最终的图像。这一阶段也是在 GPU 上运行。光栅化的任务主要是决定每个渲染图元中的哪些像素应该被绘制在屏幕上。它需要对上一个阶段得到的逐顶点数据（例如纹理坐标、顶点颜色等）进行插值，然后再进行逐像素处理。
## 1.2 CPU 和 GPU 之间的通信
渲染流水线的起点是 CPU，即应用阶段。应用阶段大致可分为下面 3 个阶段：
（1）把数据加载到显存中。
（2）设置渲染状态。
（3）调用 Draw Call（在本章的最后我们还会继续讨论它）。
### 1 .2.1　把数据加载到显存中
所有渲染所需的数据都需要从硬盘（Hard Disk Drive，HDD）中加载到系统内存（Random Access Memory，RAM）中。然后，网格和纹理等数据又被加载到显卡上的存储空间——显存（Video Random Access Memory，VRAM）中。这是因为，显卡对于显存的访问速度更快，而且大多数显卡对于 RAM 没有直接的访问权利。
![[Pasted image 20231015210654.png|475]]
▲图 1.2　渲染所需的数据（两张纹理以及 3 个网格）从硬盘最终加载到显存中。在渲染时，GPU 可以快速访问这些数据
需要注意的是，真实渲染中需要加载到显存中的数据往往比图 1.2 所示复杂许多。例如，顶点的位置信息、法线方向、顶点颜色、纹理坐标等。
当把数据加载到显存中后，RAM 中的数据就可以移除了。但对于一些数据来说，CPU 仍然需要访问它们（例如，我们希望 CPU 可以访问网格数据来进行碰撞检测），那么我们可能就不希望这些数据被移除，因为从硬盘加载到 RAM 的过程是十分耗时的。
在这之后，开发者还需要通过 CPU 来设置渲染状态，从而“指导”GPU 如何进行渲染工作。
### 1 .2.2　设置渲染状态
什么是渲染状态呢？一个通俗的解释就是，这些状态定义了场景中的网格是怎样被渲染的。例如，使用哪个顶点着色器（Vertex Shader）/片元着色器（Fragment Shader）、光源属性、材质等。如果我们没有更改渲染状态，那么所有的网格都将使用同一种渲染状态。图 2.4 显示了当使用同一种渲染状态时，渲染 3 个不同网格的结果。
![[Pasted image 20231022191317.png|525]]
在准备好上述所有工作后，CPU 就需要调用一个渲染命令来告诉 GPU：“嘿！老兄，我都帮你把数据准备好啦，你可以按照我的设置来开始渲染啦！”而这个渲染命令就是 Draw Call。
### 1 .2.3调用 Draw Call
相信接触过渲染优化的读者应该都听说过 Draw Call。实际上，Draw Call 就是一个命令，它的发起方是 CPU，接收方是 GPU。这个命令仅仅会指向一个需要被渲染的图元（primitives）列表，而不会再包含任何材质信息——这是因为我们已经在上一个阶段中完成了！
当给定了一个 Draw Call 时，GPU 就会根据渲染状态（例如材质、纹理、着色器等）和所有输入的顶点数据来进行计算，最终输出成屏幕上显示的那些漂亮的像素。而这个计算过程，就是我们下一节要讲的 GPU 流水线
![[Pasted image 20231022191506.png|500]]
## 1 .3 GPU 流水线
当 GPU 从 CPU 那里得到渲染命令后，就会进行一系列流水线操作，最终把图元渲染到屏幕上。
### 1.3.1概述
在上一节中，我们解释了在应用阶段，CPU 是如何和 GPU 通信，并通过调用 Draw Call 来命令 GPU 进行渲染。GPU 渲染的过程就是 GPU 流水线。
对于概念阶段的后两个阶段，即几何阶段和光栅化阶段，开发者无法拥有绝对的控制权，其实现的载体是 GPU。GPU 通过实现流水线化，大大加快了渲染速度。虽然我们无法完全控制这两个阶段的实现细节，但 GPU 向开发者开放了很多控制权。
几何阶段和光栅化阶段可以分成若干更小的流水线阶段，这些流水线阶段由 GPU 来实现，每个阶段 GPU 提供了不同的可配置性或可编程性。
![[Pasted image 20231022192020.png|500]]
GPU 的渲染流水线实现。颜色表示了不同阶段的可配置性或可编程性：绿色表示该流水线阶段是完全可编程控制的，黄色表示该流水线阶段可以配置但不是可编程的，蓝色表示该流水线阶段是由 GPU 固定实现的，开发者没有任何控制权。实线表示该 Shader 必须由开发者编程实现，虚线表示该 Shader 是可选的

从图中可以看出，GPU 的渲染流水线接收顶点数据作为输入。这些顶点数据是由应用阶段加载到显存中，再由 Draw Call 指定的。这些数据随后被传递给顶点着色器。
顶点着色器（Vertex Shader）
 是完全可编程的，它通常用于实现顶点的空间变换、顶点着色等功能。曲面细分着色器（Tessellation Shader）
 是一个可选的着色器，它用于细分图元。几何着色器（Geometry Shader）
 同样是一个可选的着色器，它可以被用于执行逐图元（Per-Primitive）的着色操作，或者被用于产生更多的图元。下一个流水线阶段是裁剪（Clipping）
 ，