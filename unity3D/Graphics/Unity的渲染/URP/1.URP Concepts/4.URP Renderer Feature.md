---
title: "[[4.URP Renderer Feature]]"
type: Literature
status: done
Creation Date: 2023-11-10 14:11
tags:
---
Renderer Feature是一种资源，可让您将额外的渲染通道添加到 URP 渲染器并配置其行为。这里需要与另一个更常见的概念进行区分，那就是[[Command Buffer]]，它都是一个包含了渲染命令（如 DrawMesh, Blit, SetRenderTarget  等）的列表。它是一个纯粹的“数据容器”，告诉 GPU 需要执行哪些操作。但是它本身并不知道自己应该在渲染的哪个阶段被执行。
实际上Renderer Feature 并不是 CommandBuffer 的替代品，而是它的 **管理者和宿主**。它为 CommandBuffer 在 URP 中提供了一个标准化的、功能丰富的运行环境，解决了“何时”和“如何”执行的问题，让你能更专注于“做什么”的渲染逻辑本身。
## URP Renderer Feature：高层级的注入点和管理器
URP 为了实现可编程和可扩展性，提供了一套非常清晰的结构。Renderer Feature 正是这个结构的一部分，它扮演了以下几个关键角色：
- **结构化的注入点 (Structured Injection Point)**：在旧的内置管线中，你需要用 Camera.AddCommandBuffer 并指定一个 CameraEvent 来“猜测”一个合适的时机注入 CommandBuffer。URP 通过 Renderer Feature 提供了更明确、更可靠的注入时机。你可以精确地控制你的渲染效果是在“渲染不透明物体之后”、“渲染天空盒之前”还是“所有后处理完成之前”执行。
    
- **管理 ScriptableRenderPass**：一个 Renderer Feature 的核心工作是创建和管理一个或多个 ScriptableRenderPass。ScriptableRenderPass 才是在特定时间点执行具体渲染逻辑的单元。
    
- **提供上下文 (Context)**：在 ScriptableRenderPass 的 Execute 方法中，URP 会提供 ScriptableRenderContext 和 RenderingData。
    - ScriptableRenderContext 是执行 CommandBuffer 的接口。你不再使用 Graphics.ExecuteCommandBuffer，而是通过 context.ExecuteCommandBuffer(cmd) 来提交指令。
    - RenderingData 包含了当前帧的所有渲染信息，如相机数据、剔除结果、光照信息等。这使得你的自定义渲染可以与管线的其他部分无缝协作。

[[5.Render Objects|Render Objects]]是 Unity 提供的一个内置的、开箱即用的 “Renderer Feature”。**它将一个非常常见的渲染需求（重绘部分物体）封装成了一个无需编码、配置简单的工具，极大地降低了开发者扩展 URP 渲染管线的门槛。** 

下面我要介绍的是，Renderer Feature更定制化的一些用法，请看示例。

在 URP 中，你几乎不会脱离 Renderer Feature 单独使用 CommandBuffer。实际流程如下：
1. **创建一个 MyCustomFeature.cs** (继承自 ScriptableRendererFeature)
    - 它有一个 Create() 方法，在这里 new 一个你的自定义 Pass。
    - 它有一个 AddRenderPasses() 方法，在这里把你的 Pass 添加到渲染器队列中。你可以在这里添加逻辑，决定这个 Pass 是否需要被执行。
```csharp
public class MyCustomFeature : ScriptableRendererFeature
{
    MyCustomPass myPass;

    public override void Create()
    {
        myPass = new MyCustomPass();
        // 设置 Pass 的执行时机
        myPass.renderPassEvent = RenderPassEvent.AfterRenderingOpaques;
    }

    public override void AddRenderPasses(ScriptableRenderer renderer, ref RenderingData renderingData)
    {
        renderer.EnqueuePass(myPass); // 将 Pass 注入渲染队列
    }
}
```
2. **创建一个 MyCustomPass.cs** (继承自 ScriptableRenderPass)
	- 它的 Execute() 方法是核心。**正是在这里，你创建、填充并执行 CommandBuffer**。
```csharp
public class MyCustomPass : ScriptableRenderPass
{
    public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData)
    {
        // 1. 从池中获取一个 CommandBuffer
        CommandBuffer cmd = CommandBufferPool.Get("MyCustomPass");

        // 2. 填充渲染指令
        // 例如：用一个全屏的 Blit 实现某个效果
        cmd.Blit(sourceTexture, destinationTexture, myMaterial);

        // 3. 通过 Context 执行 CommandBuffer
        context.ExecuteCommandBuffer(cmd);

        // 4. 清理 CommandBuffer 并释放回池中
        cmd.Clear();
        CommandBufferPool.Release(cmd);
    }
}
```
