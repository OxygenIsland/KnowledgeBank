---
title: "[[0.overview]]"
type: Literature
status: done
Creation Date: 2023-11-13 09:32
tags:
---
![[Screen Shot 2023-11-11 at 17.07.57.png|500]]
通俗的讲，渲染管线就是完成渲染的流水线，我们把模型数据、贴图资源以及材质参数等等，发送给 Render Pipeline，通过一些列的流水线操作把 3D 模型渲染为 2D 图像。
下面以 unity 内置的渲染管线为例进行讲解
![[Screen Shot 2023-11-11 at 17.12.08.png|475]]
![[Screen Shot 2023-11-11 at 17.13.58.png|500]]
蓝色的部分是 CPU 端要做的一些工作，绿色的部分是 GPU 端要做的工作。可以将渲染的过程当做拍照来进行理解，1、找到拍照对象（）2、放置摄像机（在 Scene 中放置好 Gameobject 和 Camera）3、按下快门（Camera 组件调用 Render 方法的过程）
Render 方法告诉引擎开始渲染，执行上图所示的一系列流程。
1、Culling 剔除（把一些看不到的或者不想看到的东西排除）可以通过相机的视锥体剔除，也可以通过遮挡剔除或者设置 culling Mask
2、剔除完成之后，要对剩下的物体确认一下渲染的先后顺序，按照这个顺序，逐个提交这些物体的模型、材质、shader 等数据给 GPU
3、发送数据
4、发送 SetPassCall 和 Drawcall 指令，告诉 GPU 渲染管线我们现在要渲染哪一些模型数据以及要用到是 shader
5、GPU 渲染管线通过一系列的渲染管线把 3D 的模型数据渲染为 2D 图像，并将图像输出到 FrameBuffer (帧缓冲区)，FrameBuffer 相当于一个屏幕大小的临时画布，等到所有的物体逐个渲染完成之后，就形成一张完整的图像了，屏幕就可以从帧缓冲区中拿到图像了
6、后处理操作允许我们在 CPU 端拿到 FrameBuffer 的图像，调用 Shader 再一次进入 GPU 渲染管线，对图像进行二次处理，例如调色、Bloom 类的后处理操作，最终显示到屏幕面前

如果场景中存在多个相机，那么每个相机都会跑一遍完整的渲染流程
![[Screen Shot 2023-11-11 at 17.37.56.png|475]]
每个 Camera 在绘制图像之前有一个 Clear 的操作（清屏），对应 unity 中的 ClearFlag；不同的 Camera 通过 Depth 来确认渲染顺序，数值小的优先被渲染，后面渲染的摄像机会把前面的图像覆盖掉。

整个渲染管线可以分为 3 大模块
![[Screen Shot 2023-11-11 at 17.48.01.png|425]]
## CPU 应用程序
- Culling
![[Screen Shot 2023-11-11 at 17.49.59.png|475]]
- Sort
![[Screen Shot 2023-11-11 at 18.00.40.png|475]]
- 打包数据
![[Screen Shot 2023-11-11 at 18.07.00.png|475]]
- 绘制调用
![[Screen Shot 2023-11-11 at 18.08.22.png|475]]
## GPU 渲染管线
![[Screen Shot 2023-11-11 at 18.13.58.png|575]]
### shader 介绍
![[Screen Shot 2023-11-11 at 18.16.44.png|525]]
第一部分的代码就是要告诉 CPU 端需要顶点的坐标和 uv, 对应的程序就会把对应的数据发送过来
拿到对应的数据之后进入到第二部分顶点 shader 的代码中，所有的顶点都会各自调用顶点 shader（并行计算），完成投影成像的转换过程（把模型空间下的顶点坐标转换到裁剪空间）。
顶点阶段要输出的内容也可以做一个自定义的操作，如第三部分的代码，输出了在裁剪空间下的顶点坐标，以便在片元 shader 中进行调用。
最后，每个片元都调用自身的片元 shader，示例的片元 shader 代码中利用顶点 shader 中传过来的 uv 坐标，对纹理贴图进行采样，最后输出最终的颜色值。
unity 中物体的渲染顺序根据 RenderQueue 来进行确认，如果物体的 RenderQueue 一样，则通过不透明队列与半透明队列的分类进行渲染，根据物体与 Camera 的距离来判定渲染顺序。
### 顶点 shader
![[Screen Shot 2023-11-11 at 18.31.46.png|475]]
![[Screen Shot 2023-11-11 at 18.33.51.png|475]]
![[Screen Shot 2023-11-11 at 18.36.32.png|475]]
![[Screen Shot 2023-11-11 at 18.40.10.png|475]]
### 光栅化
![[Screen Shot 2023-11-11 at 18.43.49.png|475]]
光栅化之后，每个片元具有以下数据
![[Screen Shot 2023-11-11 at 19.42.14.png|475]]
### 片元 shader

![[Screen Shot 2023-11-11 at 19.44.30.png|475]]
![[Screen Shot 2023-11-11 at 19.45.40.png|475]]
![[Screen Shot 2023-11-11 at 19.54.09.png|475]]
### 输出合并
![[Screen Shot 2023-11-11 at 20.03.41.png|475]]
![[Screen Shot 2023-11-11 at 20.10.46.png|475]]
一个完整的深度测试有两个选项是可以在 shader 中控制的，Zwrite 深度写入，Ztest 深度测试。如果关掉深度写入的话，即使片元通过了深度测试也不会写入深度缓冲区，但是不会影响颜色缓冲区的写入。Ztest 可以设置深度测试的规则。
![[Screen Shot 2023-11-11 at 11.44.40.png|475]]


