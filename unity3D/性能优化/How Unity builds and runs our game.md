在构建游戏时，Unity会将运行所需的所有内容打包成目标设备可执行的程序。由于CPU只能运行机器码（原生代码）这类简单语言编写的指令，无法直接执行C#等高级语言代码，因此Unity需要对代码进行转译，这个过程称为编译。

Unity的编译过程分为两个阶段：

1. 首先将脚本转换为通用中间语言Common Intermediate Language（CIL），这种语言可便捷地编译成多种原生代码
2. 随后将CIL编译为目标设备的特定原生代码

第二阶段的编译时机有两种选择：

- 构建游戏时完成（称为预编译/AOT编译）
- 在目标设备运行代码前即时编译（JIT编译）

游戏最终采用AOT还是JIT编译方式，通常取决于目标硬件的特性。

## The relationship between the code we write and compiled code
未编译的代码称为源代码。我们编写的源代码决定了编译后代码的结构与内容。通常情况下，结构良好且高效的源代码会产生同样优质的编译代码。但了解原生代码的基础知识，能帮助我们理解为何某些源代码会被编译成更高效的机器码。

需要掌握的两个核心认知：
1. 不同CPU指令的执行耗时存在差异
	- 示例：计算平方根比两个数相乘耗时更长
	- 虽然单条指令的耗时差异微乎其微，但理解"某些指令本质就更快"很有必要
	  
2. 源代码中看似简单的操作可能对应复杂的机器码
	- 示例：向列表插入元素比按索引访问数组元素需要更多指令
	- 单个操作的耗时差距虽小，但理解这些底层原理至关重要

## Run time communication between unity engin code and our script code
Unity引擎的核心功能主要由C++编写，并已预先编译为本地代码。这些已编译的引擎代码正是我们安装Unity时部署的核心组成部分。

像我们源代码这样被编译为通用中间语言（CIL）的代码称为托管代码(managed code)。当托管代码被编译为本地代码时，它会与名为"托管运行时(managed runtime)"的系统集成。该运行时负责自动内存管理和安全检查等功能，确保代码中的错误会触发异常而非直接导致设备崩溃。

当CPU在引擎代码和托管代码之间切换执行时，系统需要执行额外工作来建立这些安全检查机制。在将数据从托管代码传回引擎代码时，CPU可能需要进行数据格式转换——从托管运行时使用的格式转为引擎代码所需的格式，这个过程称为"数据封送（marshaling）"。需要强调的是，虽然单次托管代码与引擎代码间的调用开销并不显著，但我们必须清楚认识到这种成本确实存在。